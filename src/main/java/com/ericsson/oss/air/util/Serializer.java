/*******************************************************************************
 * COPYRIGHT Ericsson 2023
 *
 *
 *
 * The copyright to the computer program(s) herein is the property of
 *
 * Ericsson Inc. The programs may be used and/or copied only with written
 *
 * permission from Ericsson Inc. or in accordance with the terms and
 *
 * conditions stipulated in the agreement/contract under which the
 *
 * program(s) have been supplied.
 ******************************************************************************/

package com.ericsson.oss.air.util;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.SneakyThrows;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

public class Serializer {

    private Serializer() {
        throw new IllegalStateException("Utility class");
    }

    public static String shortHash(String s) {
        return sha1(s).substring(0, 10);
    }

    /**
     * Calculate the Hex representation SAH1 hash of a string
     *
     * @param s The string to hash
     * @return The hex string of SHA1 hash of the input string
     */
    @SneakyThrows
    public static String sha1(String s) {
            java.security.MessageDigest md = java.security.MessageDigest.getInstance("SHA-1");
            byte[] array = md.digest(s.getBytes(StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            for (byte b : array) {
                sb.append(Integer.toHexString((b & 0xFF) | 0x100), 1, 3);
            }
            return sb.toString();
    }

    /**
     * Serialize and compress an object to a BASE62 (i.e., BASE64 without + and /)
     *
     * @param pojo The object to serialize
     * @return The BASE62 encoding of the object
     */
    @SneakyThrows
    public static String encode(Object pojo) {
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(pojo);
        byte[] compressedBytes = compress(json);
        var encoded = Base64.getEncoder().encodeToString(compressedBytes);

        return fromBase64toBase62(encoded);
    }

    /**
     * Deserialize and decompress an object from a BASE64 string w/o trailing =
     *
     * @param base62                    A string generated by encode
     * @param valueType                 The type of the object to deserialize
     * @param <T>                       The type of the object to deserialize
     * @return The deserialized object
     */
    @SneakyThrows
    public static <T> T decode(String base62, Class<T> valueType) {
        String compressedBase64 = fromBase62toBase64(base62);
        byte[] compressedBytes = Base64.getDecoder().decode(compressedBase64);
        String decompressedJson = decompress(compressedBytes);
        ObjectMapper objectMapper = new ObjectMapper();
        return objectMapper.readValue(decompressedJson, valueType);
    }

    private static String fromBase64toBase62(String base64) {
        // replace each occurrence of 0,/,+, and = with 01, 02, 03, and 04 respectively
        return base64
                .replace("0", "01")
                .replace("/", "02")
                .replace("+", "03")
                .replace("=", "04");
    }

    private static String fromBase62toBase64(String base62) {
        // replace each occurrence of 01, 02, 03, and 04 with 0,/,+, and = respectively (in reverse order!!!!)
        return base62
                .replace("04", "=")
                .replace("03", "+")
                .replace("02", "/")
                .replace("01", "0");
    }

    private static byte[] compress(String data) throws IOException {
        return compress(data.getBytes(StandardCharsets.UTF_8));
    }
    private static byte[] compress(byte[] input) throws IOException {
        Deflater deflater = new Deflater(Deflater.DEFAULT_COMPRESSION);
        deflater.setInput(input);
        deflater.finish();

        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(input.length);
        byte[] buffer = new byte[1024];
        while (!deflater.finished()) {
            int count = deflater.deflate(buffer);
            outputStream.write(buffer, 0, count);
        }
        outputStream.close();

        return outputStream.toByteArray();
    }

    @SneakyThrows
    private static String decompress(byte[] compressedData) {
        Inflater inflater = new Inflater();
        inflater.setInput(compressedData);

        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(compressedData.length);
        byte[] buffer = new byte[1024];
        while (!inflater.finished()) {
            int count = inflater.inflate(buffer);
            outputStream.write(buffer, 0, count);
        }
        outputStream.close();

        return outputStream.toString(StandardCharsets.UTF_8);
    }
}
